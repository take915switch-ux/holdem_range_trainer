<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>solver plusレンジ記憶トレーニング（6-max｜UTG/HJ/CO/BTN=2.5bb・SB=3bb｜v4.10.0）</title>
<style>
  :root {
    --table-green: #116b3b; --felt: #0c7a43; --seat:#444; --seat-text:#fff; --active:#e53935;
    --selected:#42a5f5;
    --bg:#111; --card-bg:#fff; --card-outline:#ddd; --panel-bg:#1b1b1b; --panel-bd:#2d2d2d;
    --grid-bg:#141414; --cell-bd:#2a2a2a; --fill:#e53935; --label:#e9e9e9;
    --danger:#c62828;
  }
  html,body{margin:0;padding:0;background:#111;color:#eee;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Yu Gothic UI","Yu Gothic","Noto Sans JP","Meiryo",sans-serif}
  body{min-height:100vh;display:flex;flex-direction:column}
  h1{font-size:18px;margin:10px 8px;text-align:center;line-height:1.2}
  .app{width:100%;max-width:1100px;margin:0 auto;padding:6px;display:flex;flex-direction:column;gap:8px;flex:1}
  .row{display:flex;gap:10px;flex-direction:column;}
  .col{display:flex;flex-direction:column;gap:8px;flex:1}
  .table-wrap{display:flex;justify-content:center}
  .table{
    position:relative;
    width: min(94vw,420px);
    height: calc(min(94vw,420px)*0.6);
    background: radial-gradient(circle at 50% 50%, var(--felt) 0%, var(--table-green) 70%);
    border-radius: 50% / 38%;
    box-shadow: 0 10px 30px rgba(0,0,0,.45) inset, 0 8px 24px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .coin{
    position:absolute; width:18px; height:18px; border-radius:50%;
    background: radial-gradient(circle at 30% 30%, #f7e27d 0%, #efd463 35%, #e0b83a 65%, #b8862e 100%);
    border:1px solid #b88a2c;
    box-shadow: 0 1px 0 rgba(255,255,255,.35) inset, 0 2px 4px rgba(0,0,0,.4);
    transform: rotate(-8deg);
    opacity:.95;
    z-index: 1;
  }
  .coin::after{content:""; position:absolute; left:3px; top:3px; width:7px; height:3px; border-radius:50%;
    background: rgba(255,255,255,.55); filter: blur(0.2px);}
  .bb-coin1{ top:25%; left:20%; } .bb-coin2{ top:28%; left:24%; transform: rotate(12deg); }
  .sb-coin1{ bottom:25%; left:20%; transform: rotate(-3deg); }
  .seat{position:absolute; width:54px;height:24px;background:var(--seat);color:var(--seat-text);
        border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:11px;opacity:.95; z-index:2; cursor:pointer; user-select:none}
  .seat.active{background:var(--active);font-weight:700}
  .seat.pick{background:var(--selected);box-shadow:0 0 0 2px rgba(66,165,245,.3) inset}
  .seat.focus{background:var(--selected);box-shadow:0 0 0 2px rgba(66,165,245,.4) inset; font-weight:700}
  .s1{top:2%;left:50%;transform:translateX(-50%)} /* UTG */
  .s2{top:19%;right:6%} .s3{bottom:19%;right:6%} .s4{bottom:2%;left:50%;transform:translateX(-50%)} /* BTN */
  .s5{bottom:19%;left:6%} .s6{top:19%;left:6%}
  /* Panels */
  .panel{background:var(--panel-bg);border:1px solid var(--panel-bd);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px}
  .panel-head{display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap}
  .q{font-size:16px;text-align:center;margin:0; flex:1}
  .controls{display:flex;justify-content:center;gap:8px;flex-wrap:wrap}
  .choices{display:grid;grid-template-columns:repeat(5,1fr);gap:6px}
  button{padding:8px 10px;border-radius:10px;border:1px solid #3a3a3a;background:#222;color:#eee;font-size:14px}
  .choices button{padding:10px 0}
  button:active{transform:translateY(1px)}
  .btn-danger{background:#2a1a1a;border-color:#5a2a2a;color:#ffb4b4}
  .btn-danger:active{transform:translateY(1px)}
  .result{text-align:center;min-height:22px;margin-top:2px}
  .score{text-align:center;font-size:13px;opacity:.9}
  .sticky-next{position:sticky;bottom:0;display:flex;justify-content:center;background:linear-gradient(180deg, rgba(27,27,27,0), rgba(27,27,27,1));padding-top:6px;margin-top:0}
  #nextBtn{width:100%;max-width:240px}
  .hidden{display:none !important}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid #333;padding:6px 4px;text-align:center;font-size:13px}
  th{background:#232323}
  .success{color:#7bd88f}
  .meta{font-size:12px;opacity:.9;text-align:center}
  .tag{display:inline-block;padding:2px 6px;border-radius:8px;background:#2a2a2a;margin-left:6px;font-size:12px}

  /* Portrait: make choice buttons larger while fitting 5 per row */
  @media (orientation: portrait){
    .choices{ grid-template-columns: repeat(5, 1fr); gap: 8px; }
    .choices button{
      font-size: 18px;
      padding: 14px 0;
      min-height: 56px;
      border-radius: 12px;
      touch-action: manipulation;
    }
  }

  /* Landscape layout: 1:1 split, table on the left */
  @media (orientation: landscape){
    .row{ flex-direction: row; align-items: stretch; }
    .leftCol, .rightCol{ flex: 1 1 50%; min-width:0; }
    .table-wrap{ justify-content: flex-end; padding-right: 8px; }
    .rightCol{ display:flex; flex-direction:column; overflow:auto; gap:8px; }
    .rightCol > .panel, .rightCol > .viewer{ margin-bottom: 8px; }
    .table{ width: min(45vw, 520px); height: calc(min(45vw, 520px) * 0.6); }
  }

  /* Cards on table overlay */
  .deal-overlay{position:absolute; inset:0; pointer-events:none; z-index:3;}
  .cards.on-table{position:absolute; height:100%; width:100%; display:flex; gap:8px; align-items:center; justify-content:center;}
  .card{width:78px;height:112px;background:#fff;border-radius:10px;border:1px solid var(--card-outline);
        position:relative;box-shadow:0 4px 12px rgba(0,0,0,.35)}
  .cards.on-table .card{ height:20%; width:auto; aspect-ratio:78/112; }
  .rank{position:absolute;left:6px;top:4px;font-weight:700;font-size:20px}
  .rank.bottom{left:auto;right:6px;bottom:4px;top:auto;transform:rotate(180deg)}
  .pip{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:40px}
  .black{color:#111} .red{color:#c62828}
  /* On-table typography */
  .cards.on-table .card .rank{ font-size:12px; left:4px; top:2px; }
  .cards.on-table .card .rank.bottom{ right:4px; bottom:2px; }
  .cards.on-table .card .pip{ font-size:18px; }
  /* hide corner suits on table cards (we show only ranks at corners) */
  .cards.on-table .card .suit{ display:none; }

  /* Range Viewer */
  .viewer{background:var(--panel-bg); border:1px solid var(--panel-bd); border-radius:12px; padding:10px; display:flex; flex-direction:column; gap:8px}
  .viewer-header{display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap}
  .tabbar{display:flex; gap:6px; flex-wrap:wrap}
  .tabbar button{padding:6px 10px; font-size:13px}
  .tabbar button.active{background:#2d6cdf}
  .legend{display:flex; gap:10px; align-items:center; font-size:12px; opacity:.9; flex-wrap:wrap}
  .legend .box{position:relative; width:40px; height:12px; background:#181818; border:1px solid var(--cell-bd)}
  .legend .box .fill{height:100%}
  .grid-wrap{overflow:auto; max-height:58vh; border-radius:10px; border:1px solid var(--panel-bd); background:var(--grid-bg)}
  .grid{display:grid; grid-template-columns:repeat(13, minmax(22px, 1fr)); gap:1px; padding:1px}
  .cell{position:relative; background:#181818; border:1px solid var(--cell-bd); aspect-ratio:1/1; min-width:24px;
        display:flex; align-items:center; justify-content:center; font-size: clamp(9px, 1.9vw, 12px); color:var(--label);}
  .fill{position:absolute; left:0; top:0; bottom:0; width:0%; background:var(--fill); opacity:.9}
</style>
</head>
<body>
  <h1>solver plusレンジ記憶トレーニング（6-max｜UTG/HJ/CO/BTN=2.5bb・SB=3bb｜v4.10.0）</h1>
  <div class="app">
    <div class="row">
      <div class="col leftCol">
        <div class="table-wrap">
          <div class="table" aria-label="Poker Table">
            <div class="coin bb-coin1" aria-hidden="true"></div>
            <div class="coin bb-coin2" aria-hidden="true"></div>
            <div class="coin sb-coin1" aria-hidden="true"></div>

            <div class="seat s1" id="seatUTG" data-pos="UTG">UTG</div>
            <div class="seat s2" id="seatHJ" data-pos="HJ">HJ</div>
            <div class="seat s3" id="seatCO" data-pos="CO">CO</div>
            <div class="seat s4" id="seatBTN" data-pos="BTN">BTN</div>
            <div class="seat s5" id="seatSB" data-pos="SB">SB</div>
            <div class="seat s6" id="seatBB" data-pos="BB">BB</div>

            <!-- overlay for cards -->
            <div id="dealOverlay" class="deal-overlay hidden">
              <div id="hand-cards" class="cards on-table"></div>
            </div>
          </div>
        </div>
        <div class="panel" id="startPanel">
          <div class="q">出題ポジションをテーブル上でタップして選択</div>
          <div class="controls" style="justify-content:center">
            <button id="openViewerBtn">レンジ表を見る</button>
            <button id="startBtn" disabled>開始</button>
          </div>
        </div>

        <!-- Range Viewer Panel -->
        <div class="viewer hidden" id="viewerPanel" aria-hidden="true" style="display:none">
          <div class="viewer-header">
            <div class="tabbar">
              <button class="posTab active" data-pos="UTG">UTG</button>
              <button class="posTab" data-pos="HJ">HJ</button>
              <button class="posTab" data-pos="CO">CO</button>
              <button class="posTab" data-pos="BTN">BTN</button>
              <button class="posTab" data-pos="SB">SB</button>
            </div>
            <div style="display:flex; gap:8px">
              <button id="closeViewerBtn">閉じる</button>
            </div>
          </div>
          <div class="legend">
            <div>凡例：</div>
            <div class="box"><div class="fill" style="width:100%"></div></div><div>100%</div>
            <div class="box"><div class="fill" style="width:75%"></div></div><div>75%</div>
            <div class="box"><div class="fill" style="width:50%"></div></div><div>50%</div>
            <div>（赤バーは<strong>左から</strong>割合分を塗ります。左上AA／右上A2s／左下A2o／右下22）</div>
          </div>
          <div class="grid-wrap">
            <div class="grid" id="rangeGrid"></div>
          </div>
        </div>
      </div>

      <div class="col rightCol">
        <div class="panel hidden" id="quizPanel">
          <div class="panel-head">
            <p id="question" class="q"></p>
            <button id="quitBtn" class="btn-danger">やめる</button>
          </div>
          <div id="result" class="result"></div>
          <div class="controls"><div class="choices" id="buttons"></div></div>
          <div class="sticky-next"><button id="nextBtn" class="hidden">次の問題へ</button></div>
          <div class="score">進行状況: <span id="progress">0</span>/10　｜　スコア合計: <span id="score">0</span></div>
        </div>

        <div class="panel hidden" id="summaryPanel">
          <div class="q" id="summaryTitle">結果まとめ</div>
          <div class="score" id="finalBreakdown">最終スコア: 0点 + ボーナス0点</div>
          <div id="mistakeBlock" class="hidden">
            <div class="q" style="margin-top:6px;">間違えた問題の復習</div>
            <table>
              <thead><tr><th>#</th><th>Pos</th><th>Hand</th><th>実際(%)</th><th>正解ボタン</th><th>あなた</th></tr></thead>
              <tbody id="mistakeTable"></tbody>
            </table>
            <div class="controls"><button id="startReviewBtn">復習を開始</button></div>
          </div>
          <div class="controls"><button id="restartBtn">もう一度 10問</button></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===== Responsive panel placement (portrait vs landscape) ===== */
function movePanelsForOrientation(){
  const isLandscape = window.matchMedia("(orientation: landscape)").matches;
  const leftCol = document.querySelector(".leftCol");
  const rightCol = document.querySelector(".rightCol");
  const start = document.getElementById("startPanel");
  const viewer = document.getElementById("viewerPanel");
  const quiz = document.getElementById("quizPanel");
  const summary = document.getElementById("summaryPanel");
  if (!leftCol || !rightCol) return;
  if (isLandscape){
    if (start && start.parentElement !== rightCol){ rightCol.insertBefore(start, rightCol.firstChild); }
    if (viewer && viewer.parentElement !== rightCol){ rightCol.insertBefore(viewer, quiz ? quiz : rightCol.firstChild); }
  } else {
    if (start && start.parentElement !== leftCol){ leftCol.appendChild(start); }
    if (viewer && viewer.parentElement !== leftCol){ leftCol.appendChild(viewer); }
  }
}
window.addEventListener("load", movePanelsForOrientation);
window.addEventListener("resize", movePanelsForOrientation);
window.addEventListener("orientationchange", movePanelsForOrientation);

/* ===== show/hide utils ===== */
function hide(el){ if(!el) return; el.classList.add('hidden'); el.style.display='none'; el.setAttribute('aria-hidden','true'); }
function show(el){ if(!el) return; el.classList.remove('hidden'); el.style.display='block'; el.setAttribute('aria-hidden','false'); }

/* ===== Hand utils ===== */
const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
function toHandGrid(i,j){
  if (i===j) return RANKS[i]+RANKS[j];
  if (i < j) return RANKS[i]+RANKS[j]+"s"; // top-right suited (A2s)
  return RANKS[j]+RANKS[i]+"o";           // bottom-left offsuit (A2o)
}
function allHands169(){ const out=[]; for(let i=0;i<RANKS.length;i++){ for(let j=0;j<RANKS.length;j++){ out.push(toHandGrid(i,j)); } } return out; }
const ORDER = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

/* ===== position maps ===== */
const UTG = Object.fromEntries(allHands169().map(h=>[h,0]));
const HJ  = Object.fromEntries(allHands169().map(h=>[h,0]));
const CO  = Object.fromEntries(allHands169().map(h=>[h,0]));
const BTN = Object.fromEntries(allHands169().map(h=>[h,0]));
const SB  = Object.fromEntries(allHands169().map(h=>[h,0]));

/* helpers */
function setPairsAtLeast(map, lowRank){
  const start = ORDER.indexOf(lowRank);
  for (let idx=start; idx>=0; idx--){
    const r = ORDER[idx];
    map[r+r] = 100;
  }
}
function addLeftFixedPlus(map, left, right, type){
  const idx = ORDER.indexOf(right);
  if (idx === -1) return;
  const h1 = left + right + type; map[h1]=100;
  if (idx-1 >= 0){ const next = ORDER[idx-1]; const h2 = left + next + type; map[h2]=100; }
}
/* SB plus helpers */
function addSuitedPlus2(map, left, minRight){
  const li = ORDER.indexOf(left);
  const start = ORDER.indexOf(minRight);
  for (let j=start; j>li; j--){
    const r = ORDER[j];
    map[left + r + "s"] = 100;
  }
}
function addOffsuitPlus(map, left, minRight){
  const li = ORDER.indexOf(left);
  const start = ORDER.indexOf(minRight);
  for (let j=start; j>li; j--){
    const r = ORDER[j];
    map[left + r + "o"] = 100;
  }
}
function addRunLeftFixedPlus(map, left, minRight){ // e.g., 96s+ => 96s,97s,98s
  const li = ORDER.indexOf(left);
  for (let j = ORDER.indexOf(minRight); j > li; j--){
    const r = ORDER[j];
    map[left + r + "s"] = 100;
  }
}

/* ===== UTG data ===== */
for (const h of ["AA","KK","QQ","JJ","TT","99","88","77","66","AKs","AQs","AJs","ATs","A9s","A8s","A7s","A6s","A5s","A4s","A3s","A2s","KQs","KJs","KTs","K9s","QJs","QTs","JTs","T9s","AKo","AQo","AJo","KQo"]) UTG[h]=100;
for (const h of ["ATo","K8s","Q9s","KJo","J9s","55"]) UTG[h]=75;
for (const h of ["98s","87s","76s","65s","44"]) UTG[h]=50;

/* ===== HJ data ===== */
setPairsAtLeast(HJ,"5");
for (let i=ORDER.indexOf("2"); i>=1; i--){ const r=ORDER[i]; HJ["A"+r+"s"]=100; }
HJ["AA"]=100;
for (const r of ["8","9","T","J","Q"]){ HJ["K"+r+"s"]=100; } HJ["AKs"]=100;
for (const r of ["9","T","J"]){ HJ["Q"+r+"s"]=100; } HJ["KQs"]=100; HJ["AQs"]=100;
HJ["J9s"]=100;
for (const r of ["T","J","Q","K"]){ HJ["A"+r+"o"]=100; }
HJ["KJo"]=100; HJ["KQo"]=100;
for (const [hi,lo] of [["5","4"],["6","5"],["7","6"],["8","7"],["9","8"],["T","9"],["J","T"],["Q","J"],["K","Q"]]) HJ[hi+lo+"s"]=100;
for (const h of ["QJo","K7s","T8s","43s","44","33"]) HJ[h]=75;
HJ["A8s"]=100; HJ["JJ"]=100;

/* ===== CO data (with corrections) ===== */
setPairsAtLeast(CO,"2"); // 22+
for (let i=ORDER.indexOf("2"); i>=1; i--){ const r=ORDER[i]; CO["A"+r+"s"]=100; } // A2s+
for (const r of ["4","5","6","7","8","9","T","J","Q"]){ CO["K"+r+"s"]=100; } // K4s+
for (const r of ["7","8","9","T","J"]){ CO["Q"+r+"s"]=100; } // Q7s+
CO["J7s"]=100; CO["T7s"]=100;
addLeftFixedPlus(CO, "9", "7", "s"); // 97s, 98s
addLeftFixedPlus(CO, "8", "6", "s"); // 86s, 87s
for (const [hi,lo] of [["5","4"],["6","5"],["7","6"],["8","7"],["9","8"],["T","9"],["J","T"],["Q","J"],["K","Q"]]) CO[hi+lo+"s"]=100;
for (const r of ["8","9","T","J","Q","K"]){ CO["A"+r+"o"]=100; }
for (const h of ["KTo","KJo","KQo","QTo","JTo"]) CO[h]=100;
for (const h of ["A7o","K3s","Q6s","43s"]) CO[h]=75;
// Corrections
CO["QJo"]=100; CO["J9s"]=100; CO["J8s"]=100; CO["T8s"]=100;

/* ===== BTN data (with corrections) ===== */
setPairsAtLeast(BTN,"2"); // 22+
for (let i=ORDER.indexOf("2"); i>=1; i--){ const r=ORDER[i]; BTN["A"+r+"s"]=100; } // A2s+
for (let i=ORDER.indexOf("2"); i>=1; i--){ const r=ORDER[i]; BTN["K"+r+"s"]=100; } // K2s+
for (let i=ORDER.indexOf("3"); i>=1; i--){ const r=ORDER[i]; BTN["Q"+r+"s"]=100; } // Q3s+
BTN["J5s"]=100; BTN["T6s"]=100;
addLeftFixedPlus(BTN, "9", "6", "s"); // 96s, 97s
addLeftFixedPlus(BTN, "8", "6", "s"); // 86s, 87s
addLeftFixedPlus(BTN, "7", "5", "s"); // 75s, 76s
addLeftFixedPlus(BTN, "6", "4", "s"); // 64s, 65s
for (let i=ORDER.indexOf("4"); i>=1; i--){ const r=ORDER[i]; BTN["A"+r+"o"]=100; } // A4o+
for (const r of ["9","T","J","Q","K"]){ BTN["K"+r+"o"]=100; }
for (const r of ["9","T","J","Q","K"]){ BTN["Q"+r+"o"]=100; }
for (const r of ["8","9","T","J","Q","K"]){ BTN["J"+r+"o"]=100; }
for (const r of ["8","9","T","J","Q","K"]){ BTN["T"+r+"o"]=100; }
BTN["98o"]=100;
for (const h of ["A3o","A2o","K8s","Q2s","J4s","85s","63s","53s","43s"]) BTN[h]=75;
// Corrections
for (const h of ["JTs","J9s","J8s","J7s","J6s","T9s","T8s","T7s","K8s","98s","54s"]) BTN[h]=100;


/* ===== SB data (3bb Open) ===== */
setPairsAtLeast(SB,"2"); // 22+

// Suited 100%: A2s+, K2s+, Q2s+, J5s+, T5s+, 96s+, 85s+, 74s+, 64s+, 54s+
addSuitedPlus2(SB,"A","2");
addSuitedPlus2(SB,"K","2");
addSuitedPlus2(SB,"Q","2");
addSuitedPlus2(SB,"J","5");
addSuitedPlus2(SB,"T","5");
addRunLeftFixedPlus(SB,"9","6");
addRunLeftFixedPlus(SB,"8","5");
addRunLeftFixedPlus(SB,"7","4");
addRunLeftFixedPlus(SB,"6","4");
addRunLeftFixedPlus(SB,"5","4");

// Offsuit 100%: A4o+, K7o+, Q9o+, J9o+, T8o+, 98o, 87o
addOffsuitPlus(SB,"A","4");
addOffsuitPlus(SB,"K","7");
addOffsuitPlus(SB,"Q","9");
addOffsuitPlus(SB,"J","9");
addOffsuitPlus(SB,"T","8");
SB["98o"]=100;
SB["87o"]=100;

// Suited 75%: J4s, J3s, J2s, T4s, 95s, 63s, 53s, 43s
for (const h of ["J4s","J3s","J2s","T4s","95s","63s","53s","43s"]) SB[h]=75;

// Offsuit 75%: 97o, J8o, Q8o, K6o, A3o
for (const h of ["97o","J8o","Q8o","K6o","A3o"]) SB[h]=75;

/* ===== data helpers ===== */
function getMap(pos){ return pos==="UTG"?UTG:pos==="HJ"?HJ:pos==="CO"?CO:pos==="BTN"?BTN:SB; }
function toData(map,pos){ return Object.entries(map).map(([Hand,Frequency])=>({Position:pos, Hand, Frequency})); }
const DATA = { UTG: toData(UTG,"UTG"), HJ: toData(HJ,"HJ"), CO: toData(CO,"CO"), BTN: toData(BTN,"BTN"), SB: toData(SB,"SB") };

/* ===== boundary & neighbors for quiz ===== */
function boundarySetOf(map){ return new Set(Object.entries(map).filter(([,f])=>f===50||f===75).map(([h])=>h)); }
const BOUNDARY = { UTG: boundarySetOf(UTG), HJ: boundarySetOf(HJ), CO: boundarySetOf(CO), BTN: boundarySetOf(BTN), SB: boundarySetOf(SB) };
function fromHandOrder(hand){
  if (hand.length===2){ const r = ORDER.indexOf(hand[0]); return {i:r,j:r}; }
  const a=hand[0], b=hand[1], t=hand[2];
  const ia=ORDER.indexOf(a), ib=ORDER.indexOf(b);
  return t==="s" ? {i:ia,j:ib} : {i:ib,j:ia};
}
function toHandOrder(i,j){ return toHandGrid(i,j); }
function neighborsOf(handSet){
  const out = new Set();
  for (const h of handSet){
    const {i,j} = fromHandOrder(h);
    for (let di=-1; di<=1; di++){
      for (let dj=-1; dj<=1; dj++){
        if (di===0 && dj===0) continue;
        const ni=i+di, nj=j+dj;
        if (ni<0||nj<0||ni>=ORDER.length||nj>=ORDER.length) continue;
        out.add(toHandOrder(ni,nj));
      }
    }
  }
  return out;
}
const NEAR = { UTG: neighborsOf(BOUNDARY.UTG), HJ: neighborsOf(BOUNDARY.HJ), CO: neighborsOf(BOUNDARY.CO), BTN: neighborsOf(BOUNDARY.BTN), SB: neighborsOf(BOUNDARY.SB) };

/* ===== weighted sampler ===== */
function bucketsFor(pos){
  const DATASET = DATA[pos];
  const BOUND = BOUNDARY[pos];
  const NEARSET  = NEAR[pos];
  const boundary = DATASET.filter(d=>BOUND.has(d.Hand));
  const nearB    = DATASET.filter(d=>NEARSET.has(d.Hand) && !BOUND.has(d.Hand));
  const foldsNear = DATASET.filter(d=>d.Frequency===0 && NEARSET.has(d.Hand));
  const foldsOther= DATASET.filter(d=>d.Frequency===0 && !NEARSET.has(d.Hand));
  const pure     = DATASET.filter(d=>d.Frequency===100);
  return {boundary, nearB, foldsNear, foldsOther, pure};
}
function repeat(arr, times){ const out=[]; for(let t=0;t<times;t++) out.push(...arr); return out; }
function pickOne(pos){
  const b = bucketsFor(pos);
  const weighted = [
    ...repeat(b.boundary, 8),
    ...repeat(b.nearB, 5),
    ...repeat(b.foldsNear, 3),
    ...repeat(b.foldsOther, 1),
    ...repeat(b.pure, 1),
  ];
  if (!weighted.length) return null;
  return weighted[Math.floor(Math.random()*weighted.length)];
}

/* ===== seat-based position picker ===== */
const POS_IDS = ["UTG","HJ","CO","BTN","SB"];
const selectedPositions = new Set(POS_IDS); // default: all selected
for (const id of POS_IDS){
  const el = document.getElementById("seat"+id);
  el.addEventListener("click", ()=>{
    if (selectedPositions.has(id)) selectedPositions.delete(id); else selectedPositions.add(id);
    refreshPickVisuals();
    updateStartButton();
  });
}
function refreshPickVisuals(){
  for (const id of POS_IDS){
    const el = document.getElementById("seat"+id);
    el.classList.toggle('pick', selectedPositions.has(id));
  }
}
function clearPickVisuals(){
  for (const id of POS_IDS){
    const el = document.getElementById("seat"+id);
    el.classList.remove('pick');
  }
}
function setActiveSeat(pos){
  for (const id of POS_IDS){
    const el = document.getElementById("seat"+id);
    el.classList.remove('active');
    el.classList.toggle('focus', pos===id);
  }
}
function updateStartButton(){ document.getElementById("startBtn").disabled = selectedPositions.size===0; }
updateStartButton(); refreshPickVisuals();

/* ===== Cards rendering ===== */
const SUIT_SYMBOL = {S:"♠", H:"♥", D:"♦", C:"♣"};
function suitColorClass(s){ return (s==="H"||s==="D") ? "red" : "black"; }
function handToCards(hand){
  if (hand.length===2){ return [hand[0]+"S", hand[1]+"H"]; }
  const r1 = hand[0], r2 = hand[1], type = hand[2];
  if (type==="s"){ return [r1+"S", r2+"S"]; }
  return [r1+"S", r2+"H"];
}
function rankText(r){ return r==="T" ? "10" : r; }
function makeCardElement(code){
  const r = code[0];
  const s = code[1];
  const colorCls = suitColorClass(s);
  const el = document.createElement("div"); el.className = "card";
  const rankTop = document.createElement("div"); rankTop.className = `rank ${colorCls}`; rankTop.textContent = rankText(r);
  const rankBottom = document.createElement("div"); rankBottom.className = `rank bottom ${colorCls}`; rankBottom.textContent = rankText(r);
  const pip = document.createElement("div"); pip.className = `pip ${colorCls}`; pip.textContent = SUIT_SYMBOL[s];
  el.append(rankTop, pip, rankBottom);
  return el;
}

/* ===== deal overlay positioning near seats ===== */
const overlay = document.getElementById("dealOverlay");
const onTableCards = document.getElementById("hand-cards");
function placeCardsNear(pos){
  const anchorMap = {
    UTG: {top:"24%", left:"50%", transform:"translate(-50%, -50%)"},
    HJ:  {top:"36%", left:"68%", transform:"translate(-50%, -50%)"},
    CO:  {top:"64%", left:"68%", transform:"translate(-50%, -50%)"},
    BTN: {top:"76%", left:"50%", transform:"translate(-50%, -50%)"},
    SB:  {top:"64%", left:"32%", transform:"translate(-50%, -50%)"},
  };
  const a = anchorMap[pos] || {top:"50%", left:"50%", transform:"translate(-50%,-50%)"};
  onTableCards.style.top = a.top;
  onTableCards.style.left = a.left;
  onTableCards.style.transform = a.transform;
  overlay.classList.remove("hidden");
}
function hideCardsOnTable(){ overlay.classList.add("hidden"); onTableCards.innerHTML=""; }

/* ===== UI interactions ===== */
document.getElementById("openViewerBtn").addEventListener("click", ()=>{ hideCardsOnTable(); show(document.getElementById("viewerPanel")); renderGrid("UTG"); });
document.getElementById("closeViewerBtn").addEventListener("click", ()=>{ hide(document.getElementById("viewerPanel")); });
document.querySelectorAll(".posTab").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".posTab").forEach(b=>b.classList.remove("active"));
    btn.classList.add("active"); renderGrid(btn.dataset.pos);
  });
});

/* ===== Quiz controls ===== */
const CHOICES = [0,25,50,75,100];
const QUIZ_LEN = 10;
let quizPool=[], usedSet=new Set();
let questionIndex=0, current=null, history=[], inReview=false;
let startTime=0;
let basePoints=0, bonusPoints=0;
function totalScore(){ return basePoints + bonusPoints; }
(function renderButtons(){ const cont=document.getElementById("buttons"); cont.innerHTML = CHOICES.map(c=>`<button data-choice="${c}">${c}%</button>`).join(""); })();

document.getElementById("startBtn").addEventListener("click", ()=>{
  hide(document.getElementById("viewerPanel"));
  document.getElementById("startPanel").classList.add("hidden");
  document.getElementById("quizPanel").classList.remove("hidden");
  clearPickVisuals();
  // reset round state
  questionIndex = 0; basePoints = 0; bonusPoints = 0; history = []; inReview = false;
  quizPool = []; usedSet = new Set();
  document.getElementById("score").textContent="0"; document.getElementById("progress").textContent="0";
  document.getElementById("result").textContent="";
  // build pool upfront
  buildQuizPool();
  if (!quizPool || quizPool.length===0){
    const posList = Array.from(selectedPositions);
    let pool=[]; for (const pos of (posList.length?posList:["UTG","HJ","CO","BTN","SB"])) pool = pool.concat(DATA[pos]);
    shuffle(pool);
    for (const item of pool){
      const key = item.Position+"|"+item.Hand;
      if (usedSet.has(key)) continue; usedSet.add(key); quizPool.push(item);
      if (quizPool.length>=QUIZ_LEN) break;
    }
  }
  // last resort
  if (!quizPool || quizPool.length===0){ quizPool=[{Position:"UTG", Hand:"AA", Frequency:100}]; }
  newQuestion();
});
document.getElementById("buttons").addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-choice]"); if(!btn) return;
  const choice = parseInt(btn.dataset.choice,10);
  if (inReview) handleReviewAnswer(choice); else handleAnswer(choice);
});
document.getElementById("nextBtn").addEventListener("click",()=>{ if (inReview) onNextFromWrong_Review(); else onNextFromWrong_Quiz(); });
document.getElementById("restartBtn").addEventListener("click", ()=>{ quitToStart(); });
document.getElementById("startReviewBtn").addEventListener("click", ()=>{ startReview(); });
document.getElementById("quitBtn").addEventListener("click", ()=>{ quitToStart(); });

function quitToStart(){
  hide(document.getElementById("quizPanel"));
  hide(document.getElementById("summaryPanel"));
  show(document.getElementById("startPanel"));
  hideCardsOnTable();
  // reset
  quizPool=[]; usedSet=new Set(); questionIndex=0; current=null; history=[];
  inReview=false; reviewQueue=[]; reviewIndex=0; nextRoundQueue=[];
  basePoints=0; bonusPoints=0;
  document.getElementById("score").textContent="0";
  document.getElementById("progress").textContent="0";
  document.getElementById("result").textContent="";
  refreshPickVisuals();
  updateStartButton();
}

/* quiz flow */
function newQuestion(){
  if (questionIndex >= QUIZ_LEN){ return endQuiz(); }
  if (questionIndex === 0 && (!quizPool || quizPool.length===0)) buildQuizPool();
  current = quizPool[questionIndex];
  if (!current){
    const posList = Array.from(selectedPositions); let pool=[];
    for (const pos of (posList.length?posList:["UTG","HJ","CO","BTN","SB"])) pool = pool.concat(DATA[pos]);
    current = pool[Math.floor(Math.random()*pool.length)] || {Position:"UTG", Hand:"AA", Frequency:100};
    if (quizPool.length<=questionIndex) quizPool.push(current);
  }
  show(document.getElementById("quizPanel"));
  setActiveSeat(current.Position);
  document.getElementById("question").textContent = `${current.Position}: ${current.Hand} のオープン頻度は何%？`;
  onTableCards.innerHTML=""; handToCards(current.Hand).forEach(c => onTableCards.appendChild(makeCardElement(c))); placeCardsNear(current.Position);
  document.getElementById("result").textContent="";
  document.getElementById("nextBtn").classList.add("hidden");
  startTime = performance.now();
}
function nearestBucket(freq){ return CHOICES.reduce((p,c)=> Math.abs(c-freq) < Math.abs(p-freq) ? c : p, CHOICES[0]); }
function updateProgress(){ document.getElementById("progress").textContent = String(questionIndex); }
function handleAnswer(choice){
  const nearest = nearestBucket(current.Frequency);
  const correct = (choice === nearest);
  const elapsedSec = (performance.now() - startTime)/1000;
  const cat = (current.Frequency===0) ? "フォールド" : (current.Frequency===100 ? "純オープン" : "境界");
  if (correct){
    const bonus = elapsedSec <= 3 ? 3 : (elapsedSec <= 5 ? 1 : 0);
    basePoints += 1; bonusPoints += bonus;
    document.getElementById("score").textContent = String(totalScore());
    document.getElementById("result").textContent = `✅ 正解！ 正解:${nearest}%（実際:${current.Frequency}%）｜${current.Position}｜${elapsedSec.toFixed(2)}秒 ／ ボーナス +${bonus}`;
    questionIndex++; updateProgress(); setTimeout(newQuestion, 800);
  } else {
    document.getElementById("result").textContent = `❌ 不正解… 正解:${nearest}%（実際:${current.Frequency}%）｜${current.Position}`;
    document.getElementById("nextBtn").classList.remove("hidden");
  }
  history.push({pos: current.Position, hand: current.Hand, freq: current.Frequency, choice, nearest, correct, elapsedSec});
}
function onNextFromWrong_Quiz(){ questionIndex++; updateProgress(); newQuestion(); }

function buildQuizPool(){
  quizPool=[]; usedSet.clear();
  const posList = Array.from(selectedPositions);
  let attempts = 0, maxAttempts = 3000;
  while (quizPool.length < QUIZ_LEN && attempts < maxAttempts){
    attempts++;
    const pos = posList[Math.floor(Math.random()*posList.length)];
    const cand = pickOne(pos);
    if (!cand) continue;
    const key = pos+"|"+cand.Hand;
    if (usedSet.has(key)) continue;
    usedSet.add(key);
    quizPool.push(cand);
  }
  if (quizPool.length < QUIZ_LEN){
    let pool=[]; for (const pos of posList){ pool.push(...DATA[pos]); }
    shuffle(pool);
    for (const cand of pool){
      const key = cand.Position+"|"+cand.Hand;
      if (usedSet.has(key)) continue;
      usedSet.add(key);
      quizPool.push(cand);
      if (quizPool.length >= QUIZ_LEN) break;
    }
  }
}

/* end & review */
function endQuiz(){
  const quiz = document.getElementById("quizPanel");
  const summary = document.getElementById("summaryPanel");
  const startP = document.getElementById("startPanel");
  const viewer = document.getElementById("viewerPanel");
  hideCardsOnTable();
  if (quiz) quiz.classList.add("hidden");
  if (viewer) hide(viewer);
  if (startP) hide(startP);
  show(summary); // robust: ensure visible even if class state broken
  document.getElementById("finalBreakdown").textContent = `最終スコア: ${basePoints}点 + ボーナス${bonusPoints}点`;

  const dedup = new Map();
  for (const h of history){ if (!h.correct){ const key = h.pos+"|"+h.hand; if (!dedup.has(key)) dedup.set(key, h); } }
  const mistakes = Array.from(dedup.values());
  const tbody = document.getElementById("mistakeTable");
  if (mistakes.length){
    document.getElementById("mistakeBlock").classList.remove("hidden");
    tbody.innerHTML = mistakes.map((m,i)=>`<tr>
      <td>${i+1}</td><td>${m.pos}</td><td>${m.hand}</td><td>${m.freq}</td><td>${m.nearest}%</td><td>${m.choice}%</td>
    </tr>`).join("");
    reviewQueue = mistakes.map(m => ({Position:m.pos, Hand:m.hand, Frequency:m.freq}));
  } else {
    document.getElementById("mistakeBlock").classList.add("hidden");
    tbody.innerHTML = ""; reviewQueue = [];
  }

  // Ensure panel is scrolled into view in the right column
  try {
    const rightCol = document.querySelector('.rightCol');
    if (rightCol) { rightCol.scrollTop = 0; }
    summary.scrollIntoView({behavior:'instant', block:'start'});
  } catch {}
} }
  const mistakes = Array.from(dedup.values());
  const tbody = document.getElementById("mistakeTable");
  if (mistakes.length){
    document.getElementById("mistakeBlock").classList.remove("hidden");
    tbody.innerHTML = mistakes.map((m,i)=>`<tr>
      <td>${i+1}</td><td>${m.pos}</td><td>${m.hand}</td><td>${m.freq}</td><td>${m.nearest}%</td><td>${m.choice}%</td>
    </tr>`).join("");
    reviewQueue = mistakes.map(m => ({Position:m.pos, Hand:m.hand, Frequency:m.freq}));
  } else {
    document.getElementById("mistakeBlock").classList.add("hidden");
    tbody.innerHTML = ""; reviewQueue = [];
  }
}

/* review */
let reviewQueue = [], reviewIndex = 0, nextRoundQueue = [];
function startReview(){
  if (!reviewQueue.length) return;
  inReview = true;
  reviewIndex = 0; nextRoundQueue = [];
  reviewQueue = shuffle(reviewQueue.slice());
  document.getElementById("quizPanel").classList.remove("hidden");
  document.getElementById("summaryPanel").classList.add("hidden");
  document.getElementById("progress").textContent = "復習中";
  document.getElementById("score").textContent = String(totalScore());
  nextReviewQuestion();
}
function nextReviewQuestion(){
  if (reviewIndex >= reviewQueue.length){
    if (nextRoundQueue.length){
      reviewQueue = shuffle(nextRoundQueue.slice()); nextRoundQueue = []; reviewIndex = 0; nextReviewQuestion();
    } else {
      inReview = false;
      document.getElementById("quizPanel").classList.add("hidden");
      document.getElementById("summaryPanel").classList.remove("hidden");
      document.getElementById("summaryTitle").innerHTML = '結果まとめ　<span class="success">復習完了！</span>';
    }
    return;
  }
  current = reviewQueue[reviewIndex];
  setActiveSeat(current.Position);
  document.getElementById("question").textContent = `[復習] ${current.Position}: ${current.Hand} のオープン頻度は何%？`;
  onTableCards.innerHTML=""; handToCards(current.Hand).forEach(c => onTableCards.appendChild(makeCardElement(c))); placeCardsNear(current.Position);
  document.getElementById("result").textContent="";
  document.getElementById("nextBtn").classList.add("hidden");
  startTime = performance.now();
}
function handleReviewAnswer(choice){
  const nearest = nearestBucket(current.Frequency);
  const correct = (choice === nearest);
  if (correct){
    document.getElementById("result").textContent = "✅ 正解！";
    setTimeout(()=>{ reviewIndex++; nextReviewQuestion(); }, 700);
  } else {
    document.getElementById("result").textContent = `❌ 正解は ${nearest}%（実際:${current.Frequency}%）`;
    nextRoundQueue.push(current);
    document.getElementById("nextBtn").classList.remove("hidden");
  }
}
function onNextFromWrong_Review(){ reviewIndex++; nextReviewQuestion(); }

/* ===== Range Viewer render ===== */
const rangeGrid = document.getElementById("rangeGrid");
function renderGrid(pos){
  const map = getMap(pos);
  rangeGrid.innerHTML = "";
  for (let i=0; i<RANKS.length; i++){
    for (let j=0; j<RANKS.length; j++){
      const hand = toHandGrid(i,j);
      const freq = map[hand] || 0;
      const cell = document.createElement("div"); cell.className="cell";
      const fill = document.createElement("div"); fill.className="fill"; fill.style.width = (freq||0) + "%";
      const label = document.createElement("div"); label.textContent = hand; label.style.position="relative"; label.style.zIndex=1;
      cell.appendChild(fill); cell.appendChild(label);
      rangeGrid.appendChild(cell);
    }
  }
}
</script>
</body>
</html>